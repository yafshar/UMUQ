#ifndef UMHBM_PSRANDOM_H
#define UMHBM_PSRANDOM_H

#include "saruprng.hpp"

/*! \class psrandom
  *
  */
struct psrandom
{
    /*!
     * \brief Default constructor
     */
    psrandom(){};

    /*!
     * \brief constructor
     * 
     * \param seed Input seed for random number initialization 
     */
    psrandom(size_t iseed_);

    /*!
     *  \brief destructor 
     *    
     */
    ~psrandom()
    {
        destroy();
    };

    /*!
     * \brief destroy the created memory and set the static variable to NULL
     *
     */
    void destroy()
    {
        iseed = 0;

        if (NumberGenerator != nullptr)
        {
            delete[] NumberGenerator;
            NumberGenerator = nullptr;
        }

        if (saru != nullptr)
        {
            delete[] saru;
            saru = nullptr;
        }
    }

    /*!
     * \brief Init task on each node to set the current state of the engine for each thread
     */
    static void init_Task();

    /*!
     * \returns \a true when sets the current state of the engine successfully
     * 
     * \brief Sets the current state of the engine
     */
    bool init();

    /*!
     * \returns Uniform random number between [a..b)
     * 
     * \brief Uniform random number between [a..b)
     *
     * \tparam T data type one of float, double
     *
     * Advance the PRNG state by 1, and output a T precision [a..b) number (default a = 0, b = 1)
     */
    template <typename T>
    inline T unirnd(T a = 0, T b = 1)
    {
        /** left empty on purpose */
    }

    /*!
     * \returns a uniform random number of a double precision [0..1) floating point 
     * 
     * \brief Advance state by 1, and output a double precision [0..1) floating point
     * 
     * Reference:
     * Y. Afshar, F. Schmid, A. Pishevar, S. Worley, Comput. Phys. Comm. 184 (2013), 1119–1128.
     */
    inline double d() { return saru[0].d(); }

    /*!
     * \returns a uniform random number of a single precision [0..1) floating point
     * 
     * \Advance state by 1, and output a single precision [0..1) floating point
     * 
     * Reference:
     * Y. Afshar, F. Schmid, A. Pishevar, S. Worley, Comput. Phys. Comm. 184 (2013), 1119–1128.
     */
    inline float f() { return saru[0].f(); }

    /*!
     * \returns an unisgned 32 bit integer pseudo-random value
     * 
     * \brief Advance state by 1, and output a 32 bit integer pseudo-random value.
     * 
     * Reference:
     * Y. Afshar, F. Schmid, A. Pishevar, S. Worley, Comput. Phys. Comm. 184 (2013), 1119–1128.
     */
    inline unsigned int u32() { return saru[0].u32(); }

    /*!
     * \brief The Fisher-Yates shuffle is used to permute randomly given input array.
     *
     * \param idata array of input data of type int
     * \param nSize Size of the array idata
     *
     * The permutations generated by this algorithm occur with the same probability.
     *
     * References : 
     * R. Durstenfeld, "Algorithm 235: Random permutation" Communications of the ACM, 7 (1964), p. 420
     */
    void shuffle(int *idata, int nSize)
    {
        //Get the thread ID
        int me = torc_i_worker_id();

        for (int i = nSize - 1; i > 0; --i)
        {
            auto idx = saru[me].u32(i);
            std::swap(idata[i], idata[idx]);
        }
    }

    /*!
     * RNG seed
     */
    static size_t iseed;

    /*! 
     * 32-bit Mersenne Twister by Matsumoto and Nishimura, 1998
     */
    static std::mt19937 *NumberGenerator;

    /*! 
     * C++ Saru PRNG
     */
    static Saru *saru;
};

size_t psrandom::iseed = 0;
std::mt19937 *psrandom::NumberGenerator = nullptr;
Saru *psrandom::saru = nullptr;

/*!
 * \brief constructor
 * 
 * \param seed input seed for random number initialization 
 */
psrandom::psrandom(size_t const iseed_)
{
    psrandom::iseed = iseed_;

    try
    {
        //Number of local workers
        int nlocalworkers = torc_i_num_workers();
        
        psrandom::NumberGenerator = new std::mt19937[nlocalworkers];
        psrandom::saru = new Saru[nlocalworkers];
    }
    catch (std::bad_alloc &e)
    {
        std::cerr << "Error : " << __FILE__ << ":" << __LINE__ << " : " << std::endl;
        std::cerr << " Failed to allocate memory : " << e.what() << std::endl;
    };
}

/*!
 * \brief init Task on each node to set the current state of the engine
 */
void psrandom::init_Task()
{
    size_t rseed[std::mt19937::state_size];
    //Get the local number of workers
    size_t nlocalworkers = (size_t)torc_i_num_workers();
    //Node Id (MPI rank)
    size_t node_id = (size_t)torc_node_id();

    size_t n = nlocalworkers * (node_id + 1);
    for (size_t i = 0; i < nlocalworkers; i++)
    {
        size_t j = psrandom::iseed + n + i;

        for (size_t k = 0; k < std::mt19937::state_size; k++)
        {
            rseed[k] = k + j;
        }

        //Seed the engine with unsigned ints
        std::seed_seq sseq(rseed, rseed + std::mt19937::state_size);

        //For each thread feed the RNG
        psrandom::NumberGenerator[i].seed(sseq);

        Saru s(psrandom::iseed, n, i);
        psrandom::saru[i] = std::move(s);
    }
}

/*!
 * \brief Set the current state of the engine
 */
bool psrandom::init()
{
    auto initialized = 0;
    MPI_Initialized(&initialized);
    if (!initialized)
    {
        return false;
    }

    torc_register_task((void *)psrandom::init_Task);

    if (psrandom::iseed == 0)
    {
        psrandom::iseed = std::random_device{}();
    }

    int nlocalworkers = torc_i_num_workers();

    if (psrandom::NumberGenerator == nullptr)
    {
        try
        {
            psrandom::NumberGenerator = new std::mt19937[nlocalworkers];
        }
        catch (std::bad_alloc &e)
        {
            std::cerr << "Error : " << __FILE__ << ":" << __LINE__ << " : " << std::endl;
            std::cerr << " Failed to allocate memory : " << e.what() << std::endl;
            return false;
        };
    }
    if (psrandom::saru == nullptr)
    {
        try
        {
            psrandom::saru = new Saru[nlocalworkers];
        }
        catch (std::bad_alloc &e)
        {
            std::cerr << "Error : " << __FILE__ << ":" << __LINE__ << " : " << std::endl;
            std::cerr << " Failed to allocate memory : " << e.what() << std::endl;
            return false;
        };
    }

    for (int i = 0; i < torc_num_nodes(); i++)
    {
        torc_create_ex(i * nlocalworkers, 1, (void (*)())psrandom::init_Task, 0);
    }
    torc_waitall();

    return true;
}

/*!
 * \brief Uniform random number between [a..b)
 *
 * \tparam T data type one of float, double
 *
 * Advance the PRNG state by 1, and output a T precision [a..b) number (default a = 0, b = 1)
 * This is a partial specialization to make a special case for double precision uniform random number
 */
template <>
inline double psrandom::unirnd<double>(double a, double b)
{
    //Get the thread ID
    int me = torc_i_worker_id();
    return saru[me].d(a, b);
}

/*!
 * This is a partial specialization to make a special case for float precision uniform random number
 */
template <>
inline float psrandom::unirnd<float>(float a, float b)
{
    //Get the thread ID
    int me = torc_i_worker_id();
    return saru[me].f(a, b);
}

/*!
 * \brief Generates random numbers according to the Normal (or Gaussian) random number distribution
 * This class is based on psrandom object seeded engine. So to use this object there should be an instance of 
 * psrandom object.
 *
 * \tparam T data type one of float, double, or long double
 *
 */
template <typename T = double>
class normrnd
{
  public:
    /*!
     * \brief Default constructor (default mean = 0, stddev = 1)
     */
    normrnd(T mean = 0, T stddev = 1) : d(mean, stddev)
    {
        if (psrandom::iseed == 0)
        {
            std::cerr << "Error : " << __FILE__ << ":" << __LINE__ << " : " << std::endl;
            std::cerr << "You should create an instance of a psrandom object before using this class!" << std::endl;
        }
    }

    /*!
     * \returns random numbers x according to Normal (or Gaussian) random number distribution
     * The result type generated by the generator is undefined if @T is not one of float, double, or long double
     */
    T operator()()
    {
        //Get the thread ID
        int me = torc_i_worker_id();
        return d(psrandom::NumberGenerator[me]);
    }

  private:
    std::normal_distribution<T> d;
};

/*!
 * \brief Generates random numbers according to the Normal (or Gaussian) random number distribution
 * This class is independent.
 *
 * \tparam T data type one of float, double, or long double
 *
 */
template <typename T = double>
class Normrnd
{
  public:
    /*!
     * \brief Default constructor (default mean = 0, stddev = 1)
     */
    Normrnd(T mean = 0, T stddev = 1) : d(mean, stddev), gen(std::random_device{}()) {}

    /*!
     * \returns random numbers x according to Normal (or Gaussian) random number distribution
     * The result type generated by the generator is undefined if @T is not one of float, double, or long double
     */
    T operator()() { return d(gen); }

  private:
    std::mt19937 gen;
    std::normal_distribution<T> d;
};

/*!
 * \brief Generates random numbers x > 0 according to the lognormal_distribution
 * This class is based on psrandom object seeded engine. So to use this object there should be an instance of 
 * psrandom object.
 * 
 * \tparam T data type one of float, double, or long double
 *
 */
template <typename T = double>
class lognormrnd
{
  public:
    /*!
     * \brief Default constructor (default mean = 0, stddev = 1)
     */
    lognormrnd(T mean = 0, T stddev = 1) : d(mean, stddev)
    {
        if (psrandom::iseed == 0)
        {
            std::cerr << "Error : " << __FILE__ << ":" << __LINE__ << " : " << std::endl;
            std::cerr << "You should create an instance of a psrandom object before using this class!" << std::endl;
        }
    }

    /*!
     * \returns random numbers x > 0 according to the lognormal_distribution
     * The result type generated by the generator is undefined if @T is not one of float, double, or long double
     */
    T operator()()
    {
        //Get the thread ID
        int me = torc_i_worker_id();
        return d(psrandom::NumberGenerator[me]);
    }

  private:
    std::lognormal_distribution<T> d;
};

/*!
 * \brief Generates random numbers x > 0 according to the lognormal_distribution
 * This class is independent.
 * 
 * \tparam T data type one of float, double, or long double
 *
 */
template <typename T = double>
class Lognormrnd
{
  public:
    /*!
     * \brief Default constructor (default mean = 0, stddev = 1)
     */
    Lognormrnd(T mean = 0, T stddev = 1) : d(mean, stddev), gen(std::random_device{}()) {}

    /*!
     * \returns random numbers x > 0 according to the lognormal_distribution
     * The result type generated by the generator is undefined if @T is not one of float, double, or long double
     */
    T operator()() { return d(gen); }

  private:
    std::mt19937 gen;
    std::lognormal_distribution<T> d;
};

/*! \class mvnormdist
 * \brief Multivariate normal distribution
 * This class is based on psrandom object seeded engine. 
 * So to use this object there should be an instance of psrandom object.
 *
 * \tparam TM the type of the Matrix
 * \tparam TV the type of the Vector
 *
 * \tparam T data type one of float, double, or long double
 *
 */
template <typename TM, typename TV>
class mvnormdist
{
  public:
    /*!
     * \brief constructor (default mean = 0)
     *
     * \param covariance covariance Matrix
     */
    mvnormdist(TM const &covariance) : mvnormdist(TV::Zero(covariance.rows()), covariance) {}

    /*!
     * \brief constructor
     *
     * \param mean mean vector
     * \param covariance covariance Matrix
     */
    mvnormdist(TV const &mean, TM const &covariance) : mean(mean)
    {
        if (psrandom::iseed == 0)
        {
            std::cerr << "Error : " << __FILE__ << ":" << __LINE__ << " : " << std::endl;
            std::cerr << "You should create an instance of a psrandom object before using this class!" << std::endl;
        }

        // Computes eigenvalues and eigenvectors of selfadjoint matrices.
        Eigen::SelfAdjointEigenSolver<TV> es(covariance);
        transform = es.eigenvectors() * es.eigenvalues().cwiseSqrt().asDiagonal();
    }

    /*!
     * \returns a vector with multivariate normal distribution
     */
    TV operator()() const
    {
        int me = torc_i_worker_id();
        return mean + transform * TV{mean.size()}.unaryExpr([&](T x) { return d(psrandom::NumberGenerator[me]); });
    }

  private:
    TV mean;
    TM transform;
    typedef typename TM::Scalar T;
    std::normal_distribution<T> d;
};

/*! \class Mvnormdist
 * \brief Multivariate normal distribution
 * This class is independent.
 *
 * \tparam TM the type of the Matrix
 * \tparam TV the type of the Vector
 *
 * \tparam T data type one of float, double, or long double
 *
 */
template <typename TM, typename TV>
class Mvnormdist
{
  public:
    /*!
     * \brief constructor (default mean = 0)
     *
     * \param covariance covariance Matrix
     */
    Mvnormdist(TM const &covariance) : Mvnormdist(TV::Zero(covariance.rows()), covariance) {}

    /*!
     * \brief constructor
     *
     * \param mean mean vector
     * \param covariance covariance Matrix
     */
    Mvnormdist(TV const &mean, TM const &covariance) : mean(mean), gen(std::random_device{}())
    {
        // Computes eigenvalues and eigenvectors of selfadjoint matrices.
        Eigen::SelfAdjointEigenSolver<TV> es(covariance);
        transform = es.eigenvectors() * es.eigenvalues().cwiseSqrt().asDiagonal();
    }

    /*!
     * \returns a vector with multivariate normal distribution
     */
    TV operator()() const
    {
        return mean + transform * TV{mean.size()}.unaryExpr([&](T x) { return d(gen); });
    }

  private:
    TV mean;
    TM transform;
    typedef typename TM::Scalar T;
    std::mt19937 gen;
    std::normal_distribution<T> d;
};

#endif
