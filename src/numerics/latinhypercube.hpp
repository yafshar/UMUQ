#ifndef UMUQ_LATINHYPERCUBE_H
#define UMUQ_LATINHYPERCUBE_H

#include <memory>
#include <iostream>
#include <algorithm>
#include <numeric>

#include "../io/io.hpp"
#include "saruprng.hpp"

//! An instance of Saru random number generator
Saru saru;

/*!
 * \brief The Fisher-Yates shuffle is used to permute randomly given input array.
 *
 * \param idata array of input data of type int
 * \param nSize Size of the array idata
 *
 * The permutations generated by this algorithm occur with the same probability.
 *
 * References : 
 * R. Durstenfeld, "Algorithm 235: Random permutation" Communications of the ACM, 7 (1964), p. 420
 */
template <typename T>
void Shuffle(T *idata, int const nSize)
{
    for (int i = nSize - 1; i > 0; --i)
    {
        unsigned int const idx = saru.u32(i);
        std::swap(idata[i], idata[idx]);
    }
}

/*!
 * \brief Permutation base class
 * 
 * \tparam T  data type
 * \tparam PM Permutation class in a CRTP pattern to access members of the derived class
 */
template <typename T, class PM>
class Permutation
{
  public:
    /*!
     * \brief Default constructer
     * 
     */
    Permutation() : xSize(0) {}

    /*!
     * \brief Construct a new Permutation object
     * 
     * \param nSize 
     */
    Permutation(std::size_t const nSize) : xSize(nSize)
    {
        try
        {
            X.reset(new T[xSize]);
        }
        catch (std::bad_alloc &e)
        {
            std::cerr << "Error : " << __FILE__ << ":" << __LINE__ << " : " << std::endl;
            std::cerr << " Failed to allocate memory : " << e.what() << std::endl;
            throw(std::runtime_error("Not enough memory!"));
        }

        {
            T *x = X.get();
            std::iota(x, x + xSize, T{});
        }
    }

    /*!
     * \brief Move construct a new Permutation object
     * 
     * \param P object to be moved
     */
    Permutation(Permutation<T, PM> &&P)
    {
        xSize = P.xSize;
        X = std::move(P.X);
    }

    /*!
     * \brief Move assignment
     * 
     * \param P object to be moved
     * \return Permutation& 
     */
    Permutation &operator=(Permutation<T, PM> &&P)
    {
        xSize = P.xSize;
        X = std::move(P.X);
        return *this;
    }

    /*!
     * \brief Destroy the Permutation object
     * 
     */
    ~Permutation();

    /*!
     * \brief reset the permutation size
     * 
     * \param nSize new size to reset to
     */
    bool reset(std::size_t const nSize)
    {
        if (xSize > nSize)
        {
            xSize = nSize;
            {
                T *x = X.get();
                std::iota(x, x + xSize, T{});
            }
            return true;
        }

        xSize = nSize;

        try
        {
            X.reset(new T[xSize]);
        }
        catch (std::bad_alloc &e)
        {
            std::cerr << "Error : " << __FILE__ << ":" << __LINE__ << " : " << std::endl;
            std::cerr << " Failed to allocate memory : " << e.what() << std::endl;
            return false;
        }

        {
            T *x = X.get();
            std::iota(x, x + xSize, T{});
        }
        return true;
    }

    /*!
     * \brief print
     * 
     */
    void print()
    {
        if (xSize > 0)
        {
            io f;
            T *x = X.get();
            f.printMatrix<T>("Permutation: base", x, xSize);
            return;
        }
        std::cerr << "Error : " << __FILE__ << ":" << __LINE__ << " : " << std::endl;
        std::cerr << " Nothing to print! " << std::endl;
    }

    /*!
     * \brief Shuffle algorithm is used to permute randomly
     * 
     */
    void shuffle()
    {
        static_cast<PM *>(this)->shuffle();
    }

    /*!
     * \brief  operator for accessing the index id of X
     * 
     * \param  id index number
     * \return X[id]
     */
    T operator[](std::size_t const id)
    {
        return static_cast<PM *>(this)->[id];
    }

    /*!
     * \brief Get the Size object
     * 
     * \return std::size_t 
     */
    std::size_t getSize() { return xSize; }

  private:
    /*!
     * \brief Make it non copiable
     * 
     */
    Permutation(Permutation<T, PM> const &) = delete;

    Permutation &operator=(Permutation<T, PM> const &) = delete;

  protected:
    //! Size of array X
    std::size_t xSize;

    //! Base array
    std::unique_ptr<T[]> X;
};

//! \class RandomPermutation
/*!
 * \brief Random Permutation class
 * 
 * \tparam T data type
 */
template <typename T>
class RandomPermutation : public Permutation<T, RandomPermutation<T>>
{
  public:
    /*!
     * \brief Default constructer
     * 
     */
    RandomPermutation() : Permutation<T, RandomPermutation<T>>() {}

    /*!
     * \brief Construct a new Random Permutation object
     * 
     * \param nSize 
     */
    RandomPermutation(std::size_t const nSize) : Permutation<T, RandomPermutation<T>>(nSize) {}

    /*!
     * \brief Move construct a new Permutation object
     * 
     * \param P object to be moved
     */
    RandomPermutation(RandomPermutation<T> &&P) : Permutation<T, RandomPermutation<T>>(P) {}

    /*!
     * \brief Move assignment
     * 
     * \param P object to be moved
     * \return Permutation& 
     */
    RandomPermutation &operator=(RandomPermutation<T> &&P)
    {
        this->xSize = P.xSize;
        this->X = std::move(P.X);
    }

    /*!
     * \brief Destroy the Random Permutation object
     * 
     */
    ~RandomPermutation() {}

    /*!
     * \brief Shuffle algorithm is used to permute randomly given input array
     * 
     */
    void shuffle()
    {
        T *x = this->X.get();
        Shuffle<T>(x, this->xSize);
    }

  private:
    /*!
     * \brief Make it non copiable
     * 
     */
    RandomPermutation(RandomPermutation<T> const &) = delete;
    RandomPermutation &operator=(RandomPermutation<T> const &) = delete;
};

template <typename T>
class NRandomPermutation : public RandomPermutation<T>
{
  public:
    /*!
   * \brief Construct a new N-dimensional Random Permutation object
   * 
   * \param nSize 
   * \param nDim 
   */
    NRandomPermutation(std::size_t const nSize, std::size_t const nDim) : RandomPermutation<T>(std::pow(nSize, nDim)),
                                                                          basexSize(nSize),
                                                                          NDim(nDim)
    {
        try
        {
            P.reset(new RandomPermutation<T>[NDim]);
            N.reset(new std::size_t[NDim]);

            for (std::size_t i = 0; i < NDim; ++i)
            {
                P[i].reset(basexSize);
            }
        }
        catch (std::bad_alloc &e)
        {
            std::cerr << "Error : " << __FILE__ << ":" << __LINE__ << " : " << std::endl;
            std::cerr << " Failed to allocate memory : " << e.what() << std::endl;
            throw(std::runtime_error("Not enough memory!"));
        }
    }

    /*!
     * \brief Destroy the N-dimensional Random Permutation object
     * 
     */
    ~NRandomPermutation();

    /*!
     * \brief Shuffle algorithm is used to permute randomly given input array
     * 
     */
    void shuffle()
    {
        std::size_t j;
        T tmp;

        for (std::size_t i = 0; i < NDim; i++)
        {
            N[i] = 0;
            P[i].shuffle();
        }

        for (std::size_t i = 0; i < this->xSize; i++)
        {
            tmp = T{};
            for (j = NDim - 1; j >= 0; --j)
            {
                tmp = tmp * basexSize + P[j][N[j]];
            }
            this->X[i] = tmp;

            j = 0;
            do
            {
                N[j] = (N[j] + 1) % basexSize;
                j++;
            } while (j <= NDim && N[j - 1] == 0);
        }
    }

  private:
    std::size_t basexSize;
    std::size_t NDim;

    std::unique_ptr<RandomPermutation<T>[]> P;
    std::unique_ptr<std::size_t[]> N;
};

template <typename T>
class LazyRandomPermutation : public RandomPermutation<T>
{
  public:
    /*!
     * \brief Construct a new Lazy Random Permutation object
     * 
     * \param nSize 
     */
    LazyRandomPermutation(std::size_t const nSize) : RandomPermutation<T>(nSize),
                                                     clean(true),
                                                     newPerm(true) {}

    ~LazyRandomPermutation() {}

    /*!
     * \brief Shuffle algorithm is used to permute randomly given input array
     * 
     */
    void shuffle()
    {
        if (clean || newPerm)
        {
            //Compute a completely new random permutation
            newPerm = false;

            T *x = this->X.get();
            Shuffle<T>(x, this->xSize);
        }
        else
        {
            //Recycle the old permutation
            //The user has seen values _between_ <left> and <right>
            for (std::size_t i = 1; i < right - left; i++)
            {
                std::size_t const pos = saru.u32(base - i);
                std::size_t const li = (left + i) % this->xSize;
                std::size_t const lp = (left + pos) % this->xSize;

                std::swap(this->X[li], this->X[lp]);
            }
        }
        clean = true;
    }

    /*!
     * \brief  operator for accessing the index id of X
     * 
     * \param  id index number
     * \return X[id]
     */
    T operator[](std::size_t const id)
    {
        if (clean)
        {
            // initialize statistics
            left = this->xSize + id - 1;
            right = this->xSize + id + 1;
            clean = false;
        }
        else
        {
            std::size_t i;
            std::size_t dl;
            std::size_t dr;

            // update statistics
            i = this->xSize + id;

            if ((left < i) && (i < right))
            {
                return this->X[id];
            }
            if (i + this->xSize < right)
            {
                return this->X[id];
            }
            if (i - this->xSize > left)
            {
                return this->X[id];
            }
            if (id == right % this->xSize)
            {
                right++;
                return this->X[id];
            }
            if (id == left % this->xSize)
            {
                left--;
                return this->X[id];
            }

            // distance on torus from left
            dl = (left - id) % this->xSize;

            // distance on torus to right
            dr = (i + this->xSize - right) % this->xSize;

            if (dl < dr)
            {
                left = left - dl - 1;
            }
            else
            {
                right = right + dr + 1;
            }
        }
        return this->X[id];
    }

  private:
    std::size_t left;
    std::size_t right;
    std::size_t single;

    bool clean;
    bool newPerm;
};

template <typename T>
class latinHypercube
{
  public:
    LatinHypercube(std::size_t const nDim, std::size_t const len) : dimension(nDim),
                                                                    next_dim(0),
                                                                    memory(sizeof(latinHypercube<T>) + nDim * sizeof(T)),
                                                                    length(len),
                                                                    inv_length(static_cast<T>(1) / len),
                                                                    n(0),
                                                                    n0(0)
    {

        if (dimension == 0)
        {
            std::cerr << "Error : " << __FILE__ << ":" << __LINE__ << " : " << std::endl;
            std::cerr << " Dimension of sequence is 0! " << std::endl;
            throw(std::runtime_error("Wrong Dimension!"));
        }

        try
        {
            X.reset(new T[dimension]);
        }
        catch (std::bad_alloc &e)
        {
            std::cerr << "Error : " << __FILE__ << ":" << __LINE__ << " : " << std::endl;
            std::cerr << " Failed to allocate memory : " << e.what() << std::endl;
            throw(std::runtime_error("Not enough memory!"));
        }

        try
        {
            PermList.resize(dimension, std::vector<LazyRandomPermutation<T>>(length));
        }
        catch (std::bad_alloc &e)
        {
            std::cerr << "Error : " << __FILE__ << ":" << __LINE__ << " : " << std::endl;
            std::cerr << " Failed to allocate memory : " << e.what() << std::endl;
            throw(std::runtime_error("Not enough memory!"));
        }

        random_restart();
    }

    ~LatinHypercube() {}

    void check_next_dim()
    {
        if (!(next_dim == 0 || next_dim == dimension))
        {
            std::cerr << "Error : " << __FILE__ << ":" << __LINE__ << " : " << std::endl;
            std::cerr << " Warning: Not examined the whole vector " << std::endl;
        }
    }

    T operator[](std::size_t const id) const
    {
        if (id >= dimension)
        {
            std::cerr << "Error : " << __FILE__ << ":" << __LINE__ << " : " << std::endl;
            std::cerr << " Index out of range! " << std::endl;
            throw(std::runtime_error("Index out of range!"));
        }
        return X[id];
    }

    std::string query_name() { return name; }
    std::string query_filename() { return filename; }
    std::size_t query_dimension() { return dimension; }
    std::size_t memory_used() { return memory; }
    std::size_t vector_number() { return n - n0; }

    void reset_next_dim() { next_dim = 0; }

    T get_next_dim()
    {
        if (next_dim == dimension)
        {
            std::cerr << "Error : " << __FILE__ << ":" << __LINE__ << " : " << std::endl;
            std::cerr << " dimension out of range! " << std::endl;
            throw(std::runtime_error("dimension out of range!"));
        }
        return X[next_dim++];
    }

    void shuffle()
    {
        check_next_dim();

        //We have to reset next_dim in every shuffle
        reset_next_dim();

        n++;
        if (n < length)
        {
            for (std::size_t i = 0; i < dimension; i++)
            {
                X[i] = ((double)((*(PermList[i]))[n]) + drand47()) * inv_length;
            }
        }
        else
        {
            if (n == length)
            {
                cerr << "Reaching end of sequence!(LatinHypercube::operator++())"
                     << endl;
            }
            else
            {
                cerr << "Error: End of sequence! (LatinHypercube::operator++())";
                cerr << endl;
                exit(1);
            }
        }
    }

    void random_restart(void)
    {
        int i;

        n = 0;
        n--;
        for (std::size_t i = 0; i < dimension; i++)
        {
            PermList[i]->shuffle();
        }
        shuffle();
    }

  private:
    std::size_t dimension;
    std::size_t next_dim;
    std::size_t memory;
    std::size_t n;
    std::size_t n0;

    std::unique_ptr<T[]> X;
    std::unique_ptr<LazyRandomPermutation<T>[]> PermList;

    std::size_t length;
    T inv_length;
};
#endif
